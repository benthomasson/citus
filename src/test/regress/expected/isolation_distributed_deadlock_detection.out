Parsed test spec with 8 sessions

starting permutation: s1-set-deadlock-prevention s2-set-deadlock-prevention s3-set-deadlock-prevention s1-begin s2-begin s3-begin s1-update-1 s2-update-2 s3-update-3 s1-update-2 s2-update-3 s3-update-1 s3-finish s2-finish s1-finish
step s1-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;
	
    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s2-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s3-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s1-begin: 
  BEGIN;

step s2-begin: 
  BEGIN;

step s3-begin: 
  BEGIN;

step s1-update-1: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 1;

step s2-update-2: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 2;

step s3-update-3: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 3;

step s1-update-2: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 2;
 <waiting ...>
step s2-update-3: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 3;
 <waiting ...>
step s3-update-1: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 1;
 <waiting ...>
step s3-update-1: <... completed>
step s2-update-3: <... completed>
error in steps s3-update-1 s2-update-3: ERROR:  canceling statement due to user request
step s3-finish: 
  COMMIT;

step s2-finish: 
  COMMIT;

step s1-update-2: <... completed>
step s1-finish: 
  COMMIT;

restore_isolation_tester_func

               

starting permutation: s1-set-deadlock-prevention s2-set-deadlock-prevention s1-begin s2-begin s1-update-1 s2-update-2 s2-update-1 s1-update-2 s1-finish s2-finish
step s1-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;
	
    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s2-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s1-begin: 
  BEGIN;

step s2-begin: 
  BEGIN;

step s1-update-1: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 1;

step s2-update-2: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 2;

step s2-update-1: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 1;
 <waiting ...>
step s1-update-2: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 2;
 <waiting ...>
step s1-update-2: <... completed>
step s2-update-1: <... completed>
error in steps s1-update-2 s2-update-1: ERROR:  canceling statement due to user request
step s1-finish: 
  COMMIT;

step s2-finish: 
  COMMIT;

restore_isolation_tester_func

               

starting permutation: s1-set-deadlock-prevention s2-set-deadlock-prevention s3-set-deadlock-prevention s1-begin s2-begin s3-begin s2-update-1 s1-update-1 s2-update-2 s3-update-3 s3-update-2 s2-update-3 s3-finish s2-finish s1-finish
step s1-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;
	
    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s2-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s3-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s1-begin: 
  BEGIN;

step s2-begin: 
  BEGIN;

step s3-begin: 
  BEGIN;

step s2-update-1: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 1;

step s1-update-1: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 1;
 <waiting ...>
step s2-update-2: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 2;

step s3-update-3: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 3;

step s3-update-2: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 2;
 <waiting ...>
step s2-update-3: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 3;
 <waiting ...>
step s3-update-2: <... completed>
step s2-update-3: <... completed>
error in steps s3-update-2 s2-update-3: ERROR:  canceling statement due to user request
step s3-finish: 
  COMMIT;

step s2-finish: 
  COMMIT;

step s1-update-1: <... completed>
step s1-finish: 
  COMMIT;

restore_isolation_tester_func

               

starting permutation: s1-set-deadlock-prevention s2-set-deadlock-prevention s3-set-deadlock-prevention s4-set-deadlock-prevention s1-begin s2-begin s3-begin s4-begin s1-update-1 s2-update-2 s3-update-3 s3-update-2 s4-update-4 s2-update-3 s3-finish s2-finish s1-finish s4-finish
step s1-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;
	
    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s2-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s3-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s4-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s1-begin: 
  BEGIN;

step s2-begin: 
  BEGIN;

step s3-begin: 
  BEGIN;

step s4-begin: 
  BEGIN;

step s1-update-1: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 1;

step s2-update-2: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 2;

step s3-update-3: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 3;

step s3-update-2: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 2;
 <waiting ...>
step s4-update-4: 
  UPDATE deadlock_detection_test SET some_val = 4 WHERE user_id = 4;

step s2-update-3: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 3;
 <waiting ...>
step s3-update-2: <... completed>
step s2-update-3: <... completed>
error in steps s3-update-2 s2-update-3: ERROR:  canceling statement due to user request
step s3-finish: 
  COMMIT;

step s2-finish: 
  COMMIT;

step s1-finish: 
  COMMIT;

step s4-finish: 
  COMMIT;

restore_isolation_tester_func

               

starting permutation: s1-set-deadlock-prevention s2-set-deadlock-prevention s3-set-deadlock-prevention s4-set-deadlock-prevention s1-begin s2-begin s3-begin s4-begin s4-update-1 s1-update-1 s2-update-2 s3-update-3 s2-update-3 s3-update-2 s3-finish s2-finish s4-finish s1-finish
step s1-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;
	
    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s2-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s3-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s4-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s1-begin: 
  BEGIN;

step s2-begin: 
  BEGIN;

step s3-begin: 
  BEGIN;

step s4-begin: 
  BEGIN;

step s4-update-1: 
  UPDATE deadlock_detection_test SET some_val = 4 WHERE user_id = 1;

step s1-update-1: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 1;
 <waiting ...>
step s2-update-2: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 2;

step s3-update-3: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 3;

step s2-update-3: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 3;
 <waiting ...>
step s3-update-2: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 2;
 <waiting ...>
step s3-update-2: <... completed>
step s2-update-3: <... completed>
error in steps s3-update-2 s2-update-3: ERROR:  canceling statement due to user request
step s3-finish: 
  COMMIT;

step s2-finish: 
  COMMIT;

step s4-finish: 
  COMMIT;

step s1-update-1: <... completed>
step s1-finish: 
  COMMIT;

restore_isolation_tester_func

               

starting permutation: s1-set-deadlock-prevention s2-set-deadlock-prevention s3-set-deadlock-prevention s4-set-deadlock-prevention s1-begin s2-begin s3-begin s4-begin s1-update-1 s4-update-4 s2-update-2 s3-update-3 s3-update-2 s2-update-3 s4-update-1 s1-update-4 s2-finish s3-finish s1-finish s4-finish
step s1-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;
	
    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s2-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s3-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s4-set-deadlock-prevention: 
	SET citus.enable_deadlock_prevention TO off;

    -- we don't want Postgres deadlock detection to kick in
    SET deadlock_timeout TO '20min';

step s1-begin: 
  BEGIN;

step s2-begin: 
  BEGIN;

step s3-begin: 
  BEGIN;

step s4-begin: 
  BEGIN;

step s1-update-1: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 1;

step s4-update-4: 
  UPDATE deadlock_detection_test SET some_val = 4 WHERE user_id = 4;

step s2-update-2: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 2;

step s3-update-3: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 3;

step s3-update-2: 
  UPDATE deadlock_detection_test SET some_val = 3 WHERE user_id = 2;
 <waiting ...>
step s2-update-3: 
  UPDATE deadlock_detection_test SET some_val = 2 WHERE user_id = 3;
 <waiting ...>
step s4-update-1: 
  UPDATE deadlock_detection_test SET some_val = 4 WHERE user_id = 1;
 <waiting ...>
step s1-update-4: 
  UPDATE deadlock_detection_test SET some_val = 1 WHERE user_id = 4;
 <waiting ...>
step s2-update-3: <... completed>
step s3-update-2: <... completed>
step s4-update-1: <... completed>
step s1-update-4: <... completed>
error in steps s2-update-3 s3-update-2 s4-update-1 s1-update-4: ERROR:  canceling statement due to user request
error in steps s2-update-3 s3-update-2 s4-update-1 s1-update-4: ERROR:  canceling statement due to user request
step s2-finish: 
  COMMIT;

step s3-finish: 
  COMMIT;

step s1-finish: 
  COMMIT;

step s4-finish: 
  COMMIT;

restore_isolation_tester_func

               
